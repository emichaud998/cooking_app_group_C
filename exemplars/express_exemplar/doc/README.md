# Express Server Exemplar

## Overview
This exemplar shows how to set up a simple express server that contains endpoints that respond to one of each of the HTTP request methods (GET/POST/PUT/DELETE). This exemplar is meant to show the basic setup of a express server and also how to recieve and parse request paramaters sent through the body of the HTML request in JSON format. To run, first run `npm install` to create node modules files, and then run node `lib/express_server_setup.js` or `npm start`.

### GET
An endpoint that responds to HTTP GET requests should be set up using the app.get(), where app is the variable name of the created express application. A GET endpoint will typically get information from the server's database to send back to the client. For this example, an incoming request would have a recipe id or name included in JSON format in the body of the request in this general format: `{"id": 123, "name": "recipeName"}`. This exemplar shows how this id and name would be extracted from the body of the request. This id or name would then be used to call a function that would grab the correct recipe from the database, and then this recipe information would be sent back to the client with the JSON format: `{"name": "recipeName", "calories": 100, "servings": 2, "ingredients": ["ingredient1", "ingredient2"]}`.

### POST
An endpoint that responds to HTTP POST requests should be set up using the app.post(), where app is the variable name of the created express application. A POST endpoint will typically recieve information from the client to store in the server's database. For this example, an incoming request would have a recipe information included in JSON format in the body of the request in this general format: `{"name": "recipeName", "calories": 100, "servings": 2, "ingredients": ["ingredient1", "ingredient2"]}`. This exemplar shows how this information would be extracted from the body of the request. This recipe information would then be used to call a function that inserts this recipe information into the database.

### PUT
An endpoint that responds to HTTP PUT requests should be set up using the app.put(), where app is the variable name of the created express application. A PUT endpoint will typically recieve information from the client to update an existing entry in the server's database. For this example, an incoming request would have a recipe information included in JSON format in the body of the request in this general format: `{"id": 123, "name": "recipeName", newName": "newRecipeName", "newCalories": 100, "newServings": 2, "newIngredients": ["ingredient1", "ingredient2"]}`, where name or id is used to identify the particular recipe to be updated, and the rest of the fields contain information that recipe entry should be updated with. This exemplar shows how this information would be extracted from the body of the request. This recipe information would then be used to call a function that updates the recipe information in the database.

### DELETE
An endpoint that responds to HTTP DELETE requests should be set up using the app.delete(), where app is the variable name of the created express application. A DELETE endpoint will typically recieve from the client an identifying id or name of a recipe to delete from the server's database. For this example, an incoming request would have a recipe id or name included in JSON format in the body of the request in this general format: `{"id": 123, "name": "recipeName"}`. This exemplar shows how this id and name would be extracted from the body of the request. This id or name would then be used to call a function that would delete the correct recipe entry from the database.


## Why is this Useful?
This exemplar is very useful to show the basic structure that all team members should follow when setting up their Express REST API servers. Most, if not all, microservices will need to host a REST API in order to send and recieve information from other microservices. It is important that all team members know the general way to set this up, making it much easier to know the general rules for interacting with each microservice's API. THis exemplar also shows how to parse incoming JSON request parameters and send JSON responses back, which is very important since this is the general way we should be working with request and response data in each of our microservices. 